// Handle settings application and tab opening
browser.runtime.onMessage.addListener(async (message: { type: string; settings?: any }) => {
  if (message.type === 'BACKUP_PROFILE') {
    try {
      // Get current settings from storage
      const result = await browser.storage.local.get();
      return { success: true, data: result };
    } catch (error) {
      return { success: false, error: (error as Error).message };
    }
  }
  
  if (message.type === 'APPLY_SETTINGS') {
    try {
      const { settings } = message;
      // Save settings to storage
      await browser.storage.local.set(settings);
      
      // Create user.js content with header comment
      const userJsContent = [
        '// Firefox configuration generated by Firefox Configurator',
        '// Generated on: ' + new Date().toISOString(),
        '// https://github.com/bebraveronline/firefoxconfigurator',
        '',
        '/* ============================================================================',
        ' * This file contains custom Firefox preferences to enhance privacy and security.',
        ' * Review each setting carefully and modify as needed for your use case.',
        ' * ========================================================================== */',
        '',
        ...Object.entries(settings).map(([key, value]) => {
          // Add a comment describing what this preference does
          const comment = `// ${key}`;
          // Format the value based on its type
          const formattedValue = typeof value === 'string' 
            ? `"${value}"` 
            : value;
          return `${comment}\nuser_pref("${key}", ${formattedValue});`;
        })
      ].join('\n');

      // Create a data URL for the content
      const blob = new Blob([userJsContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      try {
        // Trigger download with explicit filename and saveAs
        const downloadId = await browser.downloads.download({
          url: url,
          filename: 'user.js',
          saveAs: true,
          conflictAction: 'uniquify'
        });

        // Listen for the download completion
        browser.downloads.onChanged.addListener(function onChanged(delta) {
          if (delta.id === downloadId) {
            if (delta.state?.current === 'complete') {
              // Clean up
              URL.revokeObjectURL(url);
              browser.downloads.onChanged.removeListener(onChanged);
              
              // Store settings for verification
              browser.storage.local.set({
                pendingVerification: settings,
                verificationStartTime: Date.now()
              });
            } else if (delta.error) {
              console.error('Download failed:', delta.error);
            }
          }
        });

        return { success: true };
      } catch (downloadError) {
        console.error('Download error:', downloadError);
        URL.revokeObjectURL(url);
        throw downloadError;
      }
    } catch (error) {
      console.error('Settings application error:', error);
      return { success: false, error: (error as Error).message };
    }
  }

  if (message.type === 'VERIFY_SETTINGS') {
    try {
      // Get the pending settings we need to verify
      const { pendingVerification, verificationStartTime } = await browser.storage.local.get([
        'pendingVerification',
        'verificationStartTime'
      ]);

      // If there's nothing to verify or it's been too long (15 minutes), show error
      if (!pendingVerification || !verificationStartTime || 
          Date.now() - verificationStartTime > 15 * 60 * 1000) {
        return { success: false, error: 'Verification timeout' };
      }

      // Check if all settings match what we expect
      const allSettingsMatch = Object.entries(pendingVerification).every(([key, value]) => {
        return browser.aboutConfig?.prefs?.get(key) === value;
      });

      if (allSettingsMatch) {
        // Clear verification data
        await browser.storage.local.remove(['pendingVerification', 'verificationStartTime']);
        
        // Show success page
        browser.tabs.create({
          url: 'success.html'
        });
        
        return { success: true };
      } else {
        // Show error page
        browser.tabs.create({
          url: 'error.html'
        });
        
        return { success: false, error: 'Settings mismatch' };
      }
    } catch (error) {
      return { success: false, error: (error as Error).message };
    }
  }
});

// Open extension in a new tab when the toolbar icon is clicked
browser.browserAction.onClicked.addListener(() => {
  browser.tabs.create({
    url: 'popup.html'
  });
});

// Listen for Firefox startup to verify settings
browser.runtime.onStartup.addListener(async () => {
  // Wait a bit for Firefox to fully initialize
  setTimeout(async () => {
    await browser.runtime.sendMessage({ type: 'VERIFY_SETTINGS' });
  }, 5000);
});